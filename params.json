{"name":"Eight Queens with MIPS Assembly Language","tagline":"","body":"## Eight Queens on MIPS\r\n> Zhixun TAN <br />\r\n> EE 25 <br />\r\n> 2012011120\r\n\r\nThe basic idea is putting the queens one row after another. First, we know that any two queens can't be in the same row, which indicates that for any row (0 to 7), there can only be exactly one queen.\r\n\r\nFor each row, there are 8 positions (namely columns) where we can put the queen. So we may use a number between 0 to 7 to denote the position of the queen in each row. There are 8 rows in all, meaning that we need 8 numbers. Each number requires 3 bits, so 8 numbers require 24 bits in all, which can be stored in one single `word`.\r\n\r\nHow do we check that not any two queens are in the same column? This requires us to track the previous moves before make the new move. In other words, suppose we are about to put a queen in row 3, col 4, we must first make sure that there are no previous queens in col 4. Thus, we use an 8-bit bitset to denote which columns have been 'used'.\r\n\r\nFor example, before any queen is put, the bitset is `00000000`. We put a queen in row 0, col 1, then the bitset becomes `01000000`. Then we put a queen in row 1, col 3, the bitset becomes `01010000`. Then we put a queen in row 2, col 1, but wait! -- from the bitset we know that col 1 has been occupied, so we can't do that.\r\n\r\nThe situation is similar when it comes to diagonals. There are 14 left diagonals:\r\n\r\n\t 7  8  9 10 11 12 13 14\r\n\t 6  7  8  9 10 11 12 13\r\n\t 5  6  7  8  9 10 11 12\r\n\t 4  5  6  7  8  9 10 11\r\n\t 3  4  5  6  7  8  9 10\r\n\t 2  3  4  5  6  7  8  9\r\n\t 1  2  3  4  5  6  7  8\r\n\t 0  1  2  3  4  5  6  7\r\n\r\nThere are also 14 right diagonals.\r\n\r\n### Python version of Eight Queens:\r\nHere we give the python version of the algorithm above.\r\n\r\n\tnum = 8\r\n\tcurr = 0\r\n\tvert = 0\r\n\tldiag = 0\r\n\trdiag = 0\r\n\trow = 0\r\n\tpos = 0\r\n\tcount = 0\r\n\t\r\n\twhile (True):\r\n\t    if pos == num and row == 0: # BREAK\r\n\t        break\r\n\t    \r\n\t    if row == num: # success\r\n\t        print oct(curr)\r\n\t        pos = curr & 7\r\n\t        curr = curr >> 3\r\n\t\r\n\t        row -= 1\r\n\t        vert = vert & (~(1 << pos))\r\n\t        ldiag = ldiag & (~(1 << (7 - row + pos)))\r\n\t        rdiag = rdiag & (~(1 << (row + pos)))\r\n\t        pos += 1\r\n\t        count += 1\r\n\t        continue\r\n\t\r\n\t    if pos == num and row != 0: # POP\r\n\t        pos = curr & 7\r\n\t        curr = curr >> 3\r\n\t        \r\n\t        row -= 1\r\n\t        vert = vert & (~(1 << pos))\r\n\t        ldiag = ldiag & (~(1 << (7 - row + pos)))\r\n\t        rdiag = rdiag & (~(1 << (row + pos)))\r\n\t        pos += 1\r\n\t        continue\r\n\t\r\n\t    # PUSH\r\n\t    # Check the correctness of this move.\r\n\t    t_vert = 1 << pos\r\n\t    t_ldiag = 1 << (7 - row + pos)\r\n\t    t_rdiag = 1 << (row + pos)\r\n\t    \r\n\t    fail = vert & t_vert\r\n\t    fail = fail | (ldiag & t_ldiag)\r\n\t    fail = fail | (rdiag & t_rdiag)\r\n\t    \r\n\t    if fail == 0:\r\n\t        curr = curr << 3\r\n\t        curr = curr | pos\r\n\t        \r\n\t        vert = vert | t_vert\r\n\t        ldiag = ldiag | t_ldiag\r\n\t        rdiag = rdiag | t_rdiag\r\n\t        pos = 0\r\n\t        row += 1\r\n\t        \r\n\t    else:\r\n\t        pos += 1\r\n\t    \r\n\tprint count\r\n\r\n\r\n### RESULT\r\n<center>\r\n![](http://www.phisiart.com/pics/spim.png)\r\n</center>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}